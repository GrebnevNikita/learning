<?php
/*


$output = `php -f ./test_2.php`;
echo "<pre>$output</pre>";



phpinfo();
 console
 php -f LEARNING/test_1.php

if (str_contains($_SERVER['HTTP_USER_AGENT'], 'Firefox')) {
    echo 'Вы используете Firefox.';
}


ini_set('memory_limit', '7000M');
ini_set('max_execution_time', 1200);
session_start();


error_reporting(E_ERROR);
error_reporting(E_ERROR | E_WARNING | E_PARSE);
ini_set('display_errors', 0);
ini_set('display_errors', 1);
error_reporting(E_ALL);
ini_set('display_errors', true);
ini_set('html_errors', false);

htmlspecialchars() обеспечивает правильную кодировку "особых" HTML-символов так,
 чтобы вредоносный HTML или Javascript не был вставлен на вашу страницу.

htmlentities() — Преобразовывает все возможные символы в соответствующие HTML-сущности


settype($foo, "integer"); // $foo теперь 5 (целое число)
settype($bar, "string");  // $bar теперь "1" (строка)

$a_bool = true;   // логическое значение
$a_str  = "foo";  // строка
$a_str2 = 'foo';  // строка
$an_int = 12;     // целое число

echo gettype($foo);

echo get_debug_type($a_bool), "\n";//bool
echo get_debug_type($a_str), "\n";//string


 Если это целое число, увеличить на четыре
if (is_int($an_int)) {
    $an_int += 4;
}
var_dump($an_int); //int(16)

 Если $a_bool - это строка, вывести её
if (is_string($a_bool)) {
    echo "Строка: $a_bool";
}

var_dump((bool) "");        // bool(false)
var_dump((bool) "0");       // bool(false)
var_dump((bool) 1);         // bool(true)
var_dump((bool) -2);        // bool(true)
var_dump((bool) "foo");     // bool(true)
var_dump((bool) 2.3e5);     // bool(true)
var_dump((bool) array(12)); // bool(true)
var_dump((bool) array());   // bool(false)
var_dump((bool) "false");   // bool(true)


UINT_MAX	Максимальное значение для переменной типа unsigned int.	4 294 967 295 (0xffffffff)
LONG_MIN	Минимальное значение для переменной типа long.	-2 147 483 648
LONG_MAX	Максимальное значение для переменной типа long.	2 147 483 647

1-2
2-4
3-8
4-16
5-32
6-64
7-128
8-256
9-512
10-1024
11-2048
12-4096
13-8192
14-16384
15-32768
16-65536
17-131072
18-262144
19-524288
20-1048576
21-2097152
22-4194304
23-8388608
24-16777216
25-33554432
26-67108864
27-134217728
28-268435456
29-536870912
30-1073741824
31-2147483648 int 2147483647
32-4294967296
33-8589934592


var_dump
int(2305843009213693952) -61-2305843009213693952
int(4611686018427387904) -62-4611686018427387904
float(9.2233720368548E+18) -63-9.2233720368548E+18
float(1.844674407371E+19) -64-1.844674407371E+19

gettype
integer-61-2305843009213693952
integer-62-4611686018427387904
double-63-9.2233720368548E+18
double-64-1.844674407371E+19




Сравнение чисел с плавающей точкой ¶
$a и $b равны до 5-ти знаков после точки.
$a = 1.23456789;
$b = 1.23456780;
$epsilon = 0.00001;

if (abs($a - $b) < $epsilon) {
    echo "true";
}
$x = 8 - 6.4;  // which is equal to 1.6
$y = 1.6;
var_dump($x == $y); // is not true
PHP thinks that 1.6 (coming from a difference) is not equal to 1.6. To make it work, use round()
var_dump(round($x, 2) == round($y, 2)); // this is true
This happens probably because $x is not really 1.6, but 1.599999.. and var_dump shows it to you as being 1.6.






$juices = array("apple", "orange", "koolaid1" => "purple");

echo "He drank some $juices[0] juice.".PHP_EOL;
echo "He drank some $juices[1] juice.".PHP_EOL;
echo "He drank some $juices[koolaid1] juice.".PHP_EOL;



class people {
    public $john = "John Smith";
    public $jane = "Jane Smith";
    public $robert = "Robert Paulsen";
    public $smith = "Smith";
}

$people = new people();

echo "$people->john drank some $juices[0] juice.";
echo "$people->john then said hello to $people->jane.";
echo "$people->john's wife greeted $people->robert.";
echo "$people->robert greeted the two $people->smith.";




$array = array(
    1    => "a",
    "1"  => "b",
    1.5  => "c",
    true => "d",
);

$array = array(
    "a",
    "b",
    6 => "c",
    "d",
);

$array = array(
    1    => 'a',
    '1'  => 'b', // значение «b» перезапишет значение «a»
    1.5  => 'c', // значение «c» перезапишет значение «b»
    -1 => 'd',
    '01'  => 'e', // поскольку это не целочисленная строка, она НЕ перезапишет ключ 1
    '1.5' => 'f', // поскольку это не целочисленная строка, она НЕ перезапишет ключ 1
    true => 'g', // значение «g» перезапишет значение «c»
    false => 'h',
    '' => 'i',
    null => 'j', // значение «j» перезапишет значение «i»
    'k', // значение «k» присваивается ключу 2. Потому что самый большой целочисленный ключ до этого был 1
    2 => 'l', // значение «l» перезапишет значение «k»
);

$array = array(
    "foo" => "bar",
    42    => 24,
    "multi" => array(
        "dimensional" => array(
            "array" => "foo"
        )
    )
);

var_dump($array["foo"]);
var_dump($array[42]);
var_dump($array["multi"]["dimensional"]["array"]);

$arr[] = 56;
$arr["x"] = 42;
unset($arr[5]); // Это удаляет элемент из массива
unset($arr);    // Это удаляет весь массив



1	E_ERROR (int)	Фатальные ошибки времени выполнения. Это неустранимые средствами самого скрипта ошибки, такие как ошибка распределения памяти и т.п. Выполнение скрипта в таком случае прекращается.
2	E_WARNING (int)	Предупреждения времени выполнения (не фатальные ошибки). Выполнение скрипта в таком случае не прекращается.
4	E_PARSE (int)	Ошибки на этапе компиляции. Должны генерироваться только парсером.
8	E_NOTICE (int)	Уведомления времени выполнения. Указывают на то, что во время выполнения скрипта произошло что-то, что может указывать на ошибку, хотя это может происходить и при обычном выполнении программы.
16	E_CORE_ERROR (int)	Фатальные ошибки, которые происходят во время запуска РНР. Такие ошибки схожи с E_ERROR, за исключением того, что они генерируются ядром PHP.
32	E_CORE_WARNING (int)	Предупреждения (не фатальные ошибки), которые происходят во время начального запуска РНР. Такие предупреждения схожи с E_WARNING, за исключением того, что они генерируются ядром PHP.
64	E_COMPILE_ERROR (int)	Фатальные ошибки на этапе компиляции. Такие ошибки схожи с E_ERROR, за исключением того, что они генерируются скриптовым движком Zend.
128	E_COMPILE_WARNING (int)	Предупреждения на этапе компиляции (не фатальные ошибки). Такие предупреждения схожи с E_WARNING, за исключением того, что они генерируются скриптовым движком Zend.
256	E_USER_ERROR (int)	Сообщения об ошибках, сгенерированные пользователем. Такие ошибки схожи с E_ERROR, за исключением того, что они генерируются в коде скрипта средствами функции PHP trigger_error().
512	E_USER_WARNING (int)	Предупреждения, сгенерированные пользователем. Такие предупреждения схожи с E_WARNING, за исключением того, что они генерируются в коде скрипта средствами функции PHP trigger_error().
1024	E_USER_NOTICE (int)	Уведомления, сгенерированные пользователем. Такие уведомления схожи с E_NOTICE, за исключением того, что они генерируются в коде скрипта, средствами функции PHP trigger_error().
2048	E_STRICT (int)	Включаются для того, чтобы PHP предлагал изменения в коде, которые обеспечат лучшее взаимодействие и совместимость кода.
4096	E_RECOVERABLE_ERROR (int)	Фатальные ошибки с возможностью обработки. Такие ошибки указывают, что, вероятно, возникла опасная ситуация, но при этом, скриптовый движок остаётся в стабильном состоянии. Если такая ошибка не обрабатывается функцией, определённой пользователем для обработки ошибок (смотрите set_error_handler()), выполнение приложения прерывается, как происходит при ошибках E_ERROR.
8192	E_DEPRECATED (int)	Уведомления времени выполнения об использовании устаревших конструкций. Включаются для того, чтобы получать предупреждения о коде, который не будет работать в следующих версиях PHP.
16384	E_USER_DEPRECATED (int)	Уведомления времени выполнения об использовании устаревших конструкций, сгенерированные пользователем. Такие уведомления схожи с E_DEPRECATED за исключением того, что они генерируются в коде скрипта, с помощью функции PHP trigger_error().
32767	E_ALL (int)	Все поддерживаемые ошибки, предупреждения и замечания.





Простая распаковка массива
Работает также с синтаксисом array().
$arr1 = [1, 2, 3];
$arr2 = [...$arr1]; // [1, 2, 3]
$arr3 = [0, ...$arr1]; // [0, 1, 2, 3]
$arr4 = [...$arr1, ...$arr2, 111]; // [1, 2, 3, 1, 2, 3, 111]
$arr5 = [...$arr1, ...$arr1]; // [1, 2, 3, 1, 2, 3]



$testCase = array(
    1 => '',
    2 => "",
    3 => null,
    4 => array(),
    5 => FALSE,
    6 => NULL,
    7=>'0',
    8=>0,

);

foreach ($testCase as $k => $v) {
    if (empty($v)) {
        echo "<br> $k=>$v is empty";
    }
}
/**
Output
1=> is empty
2=> is empty
3=> is empty
4=>Array is empty
5=> is empty
6=> is empty
7=>0 is empty
8=>0 is empty



Пример передачи замыкания в callback-параметр

 Замыкание
$double = function($a) {
    return $a * 2;
};
Диапазон чисел
$numbers = range(1, 5);

Передаём в параметр замыкание в качестве callback-функции
для удвоения каждого элемента в созданном выше диапазоне
$new_numbers = array_map($double, $numbers);
array_map — Применяет callback-функцию ко всем элементам указанных массивов
print implode(' ', $new_numbers);

Результат выполнения приведённого примера:
2 4 6 8 10

Тип mixed принимает любое значение. Он эквивалентен объединению типов object|resource|array|string|float|int|bool|null. Тип доступен с PHP 8.0.0.
На языке теории типов, mixed — верхний тип. Остальные типы — его подтипы.


Void ¶
void — это тип, который допустимо указывать только как возвращаемое значение, которое указывает, что функция не возвращает значение, зато работу функции по-прежнему можно прерывать. Поэтому его нельзя объявлять в объединении типов. Тип доступен с PHP 7.1.0.
Замечание: Даже если объявить, что функция возвращает тип void, она всё равно вернёт значение null.


Конструктор – это метод, который вызывается автоматически при создании объекта класса. Конструкторы в PHP имеют имя “__construct()“. Они могут использоваться для инициализации свойств объекта. Например:
Деструктор – это метод, который вызывается автоматически при уничтожении объекта класса. Деструкторы в PHP имеют имя “__destruct()“. Они могут использоваться для освобождения ресурсов, которые занимал объект. Например:


В этом примере класс Bat использует трейты Animal и CanFly для доступа к их свойствам и методам.

Трейты – это более гибкий и безопасный способ реализации функциональности, похожей на множественное наследование, в PHP.

Почему PHP не поддерживает множественное наследование классов?

Существует несколько причин, почему PHP не поддерживает множественное наследование классов:

Сложность: Множественное наследование может привести к сложным и запутанным иерархиям классов, что может затруднить чтение и сопровождение кода.
Проблемы с алмазными конфликтами: Если два родительских класса имеют метод с одинаковым именем, то возникает алмазный конфликт, и неясно, какой метод должен быть вызван.
Производительность: Множественное наследование может привести к снижению производительности, так как код должен будет выполнять поиск в нескольких иерархиях классов.
Использование трейтов – это более простой, понятный и эффективный способ реализации функциональности, похожей на множественное наследование, в PHP.



Приватный метод (свойство) (он же private) - такой метод (свойство), доступ к которому можно получить только из того же класса (или объекта того же класса).

Защищенный метод (свойство) (он же protected) - такой метод (свойство), доступ к которому можно получить только из того же класса (или объекта того же класса) и из его наследников.

Публичный метод (свойство) (он же public) - такой метод (свойство), доступ к которому можно получить откуда угодно - извне определенного класса, из объекта определенного класса, из наследников.



Относительные типы классов ¶
Эти объявления типов можно использовать только внутри классов.
self ¶
Значение должно быть instanceof того же класса, что и класс, в котором используется объявление типа.
parent ¶
Значение должно быть instanceof родительского класса, наследуемого классом, в котором объявляется тип.
static ¶
static — это тип только для возвращаемого значения, который требует, чтобы возвращаемое значение было instanceof того же класса, что и класс, в котором вызывается метод. Доступен научная с PHP 8.0.0.





Камень второй — методы существуют в единственном экземпляре.
Тут всё чуть сложнее. Для понимания сути приведу код:
class A {
  public function foo() {
    static $x = 0;
    echo ++$x;
  }
}

$a1 = new A;
$a2 = new A;

$a1->foo(); // 1
$a2->foo(); // 2
$a1->foo(); // 3
$a2->foo(); // 4

Вопреки интуитивному ожиданию «разные объекты — разные методы» мы наглядно видим на этом примере, что динамические методы в PHP «не размножаются». Даже если у нас будет сто объектов этого класса, метод будет существовать лишь в одном экземпляре, просто при каждом вызове в него будет пробрасываться разный $this.

Такое поведение может быть неожиданным для неподготовленного к нему разработчика и послужить источником ошибок. Нужно заметить, что наследование класса (и метода) приводит к тому, что всё-таки создается новый метод:

class A {
  public function foo() {
    static $x = 0;
    echo ++$x;
  }
}

class B extends A {
}

$a1 = new A;
$b1 = new B;

$a1->foo(); // 1
$b1->foo(); // 1
$a1->foo(); // 2
$b1->foo(); // 2







Основы ¶
Переменные в PHP представлены знаком доллара с последующим именем переменной. Имя переменной чувствительно к регистру.
Имена переменных соответствуют тем же правилам, что и остальные наименования в PHP.
 Правильное имя переменной должно начинаться с буквы или символа подчёркивания и состоять из букв, цифр и символов подчёркивания в любом количестве.
 Это можно отобразить регулярным выражением: ^[a-zA-Z_\x80-\xff][a-zA-Z0-9_\x80-\xff]*$













*/

















