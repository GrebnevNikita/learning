<?php
/*
 <?=  = <?php echo

Продвинутое изолирование с использованием условий
$expression = false;
?>
<?php if ($expression == true): ?>
    Это будет отображено, если выражение истинно.
<?php else: ?>
    В ином случае будет отображено это.
<?php endif; ?>

<?php



https://www.php.net/manual/ru/install.windows.php

 Это однострочный комментарий в стиле C++
/* Это многострочный комментарий
   ещё одна строка комментария */
# Это комментарий в стиле оболочки Unix

/*
======================================================================
 CATEGORY LARGE FONT
======================================================================

-----------------------------------------------------
 Sub-Category Smaller Font
-----------------------------------------------------

/* Title Here Notice the First Letters are Capitalized */

# Option 1
# Option 2
# Option 3

/*
 * This is a detailed explanation
 * of something that should require
 * several paragraphs of information.
 */

/*

Язык PHP использует систему номинальных типов с сильным отношением поведенческого подтипирования. PHP проверяет отношение подтипов во время компиляции, тогда как контроль типов язык выполняет динамически во время выполнения.

https://www.php.net/manual/ru/language.types.type-system.php

Система типов PHP поддерживает атомарные типы, которые разрешено объединять, чтобы создавать сложные типы. Часть этих типов допустимо записывать в объявлениях типов.



Список базовых типов:
Встроенные типы
    null,array,object,resource,never,void
    Скалярные типы:bool,int,float,string
    «Относительные типы классов»: self, parent и static
Типы значений
    false
    true
Определяемые пользователем типы (часто называемые класс-типами)
    Интерфейсы
    Классы
    Перечисления
callable

Составные типы ¶
Возможно объединение нескольких атомарных типов в составные типы. PHP разрешает объединять типы следующими способами:
    Пересечение типов принимает значения, которые удовлетворяют не одному, а одновременно нескольким объявлениям класс-типов. Отдельные пересекающиеся типы соединяются символом &. Поэтому пересечение типов T, U и V, будет записано как T&U&V.
Объединение типов принимает значения нескольких отличающихся типов, а не одного. Отдельные объединяемые типы соединяются символом |. Поэтому объединение типов T, U и V, будет записано как T|U|V. Если при объединении типов добавляют пересечение типов, то пересечение типов берут в скобки для записи в дизъюнктивной нормальной форме (DNF): T|(X&Y).



Тип null — это единичный тип PHP, то есть он имеет только одно значение: null.
Неопределённые и удалённые языковой конструкцией unset() переменные преобразуются в значение null.
is_null()
unset()

У логического типа (bool) есть только два значения и они выражают истинность значения. Он может быть либо true, либо false.


$a = 1234; // десятичное число
$a = 0123; // восьмеричное число (эквивалентно 83 в десятичной системе)
$a = 0x1A; // шестнадцатеричное число (эквивалентно 26 в десятичной системе)
$a = 0b11111111; // двоичное число (эквивалентно 255 в десятичной системе)
$a = 1_234_567; // десятичное число (с PHP 7.4.0)

var_dump(foo(8.1)); // "Deprecated: Implicit conversion from float 8.1 to int loses precision" начиная с PHP 8.1.0
var_dump(foo(8.1)); // 8 до PHP 8.1.0
var_dump(foo(8.0)); // 8 в обоих случаях

var_dump((int)8.1); // 8 в обоих случаях
var_dump(intval(8.1)); // 8 в обоих случаях





Третий способ определения строк — это heredoc-синтаксис: <<<. Следом за этим оператором указывают идентификатор, а затем перевод строки. Затем идёт сама строка, за которой снова идёт тот же идентификатор, чтобы закрыть вставку.
 без отступов
echo <<<END
      a
     b
    c
\n
END;

 4 отступа
echo <<<END
      a
     b
    c
    END;


class beers {
    const softdrink = 'rootbeer';
    public static $ale = 'ipa';
}

$rootbeer = 'A & W';
$ipa = 'Alexander Keith\'s';

 Это работает, выводит: Я бы хотел A & W
echo "Я бы хотел {${beers::softdrink}}\n";

 Это тоже работает, выводит: Я бы хотел Alexander Keith's
echo "Я бы хотел {${beers::$ale}}\n";



Деструктуризация массива ¶
Массивы разрешено деструктурировать языковыми конструкциями [] (начиная с PHP 7.1.0) или list(). Эти языковые конструкции разрешено использовать для деструктуризации массива на отдельные переменные.


$source_array = ['foo', 'bar', 'baz'];
[$foo, $bar, $baz] = $source_array;
echo $foo;    // выведет «foo»
echo $bar;    // выведет «bar»
echo $baz;    // выведет «baz»

    Деструктуризацию массива также выполняют в конструкции foreach для деструктуризации многомерного массива во время итерации по массиву.


$source_array = [
    [1, 'John'],
    [2, 'Jane'],
];
foreach ($source_array as [$id, $name]) {
    // логика работы с $id и $name
}

$source_array = ['foo' => 1, 'bar' => 2, 'baz' => 3];

 Присваивание элемента с индексом «baz» переменной $three
['baz' => $three] = $source_array;

echo $three;    // выведет 3

$source_array = ['foo', 'bar', 'baz'];

 Присваивание элемента с индексом 2 переменной $baz
[2 => $baz] = $source_array;

echo $baz;    // выведет «baz»

Деструктуризацией массив пользуются, чтобы поменять две переменные местами.


$a = 1;
$b = 2;
[$b, $a] = [$a, $b];
echo $a;    // выведет 2
echo $b;    // выведет 1

$a = array(1 => 'один', 2 => 'два', 3 => 'три');
unset($a[2]);
 даст массив, представленный так:
   $a = array(1 => 'один', 3 => 'три');
   а НЕ так:
   $a = array(1 => 'один', 2 => 'три');


$b = array_values($a);
 Теперь $b это array(0 => 'один', 1 => 'три')

$arr = array('fruit' => 'apple', 'veggie' => 'carrot');

 Давайте определим константу, чтобы продемонстрировать, что
 происходит. Присвоим константе с именем fruit значение «veggie».
define('fruit', 'veggie');

 Теперь обратите внимание на разницу
print $arr['fruit'];  // apple
print $arr[fruit];    // carrot

PHP поддерживает один оператор управления ошибками: знак @. В случае если он предшествует какому-либо выражению в PHP-коде, любые сообщения об ошибках, генерируемые этим выражением, будут подавлены.


 Преднамеренная ошибка при работе с файлами
$my_file = @file ('non_existent_file') or
die ("Ошибка при открытии файла: сообщение об ошибке было таким: '" . error_get_last()['message'] . "'");

 работает для любых выражений, а не только для функций
$value = @$cache[$key];
 В случае если ключа $key нет, сообщение об ошибке (notice) не будет отображено

* so what does the @ operator do? It temporarily sets the error reporting level to 0 for that line. If that line triggers an error, the error handler will still be called, but it will be called with an error level of 0



Преобразование в массив ¶
Преобразование целого числа (int),
 числа с плавающей точкой (float), строки (string),
 логического значения (bool) или ресурса (resource)
 в массив — создаёт массив с одним элементом с индексом 0 и значением скаляра,
 который был преобразован. Говоря по-другому, выражение (array) $scalarValue аналогично выражению array($scalarValue).

Если объект (object) будет преобразован в массив,
 элементами массива будут свойства (переменные-члены) этого объекта.
 Ключами будут имена переменных-членов, со следующими примечательными исключениями:
 целочисленные свойства станут недоступны; к закрытым полям класса (private) в начало будет дописано имя класса;
 к защищённым полям класса (protected) в начало будет добавлен символ '*'.
 Эти добавленные с обоих сторон значения также получат NUL-байты.
 Неинициализированные типизированные свойства автоматически отбрасываются.


class A {
    private $B;
    protected $C;
    public $D;
    function __construct()
    {
        $this->{1} = null;
    }
}
var_export((array) new A());

Результат выполнения приведённого примера:

array (
  '' . "\0" . 'A' . "\0" . 'B' => NULL,
  '' . "\0" . '*' . "\0" . 'C' => NULL,
  'D' => NULL,
  1 => NULL,
)
Это может вызвать несколько неожиданное поведение:


class A {
    private $A; // Это станет '\0A\0A'
}
class B extends A {
    private $A; // Это станет '\0B\0A'
    public $AA; // Это станет 'AA'
}
var_dump((array) new B());

Результат выполнения приведённого примера:

array(3) {
  ["BA"]=>
  NULL
  ["AA"]=>
  NULL
  ["AA"]=>
  NULL
}


 В то же время это нормально, поскольку объекты могут быть преобразованы в строку.
class S {
  private $v;

  public function __construct(string $v) {
    $this->v = $v;
  }

  public function __toString() {
    return $this->v;
  }
}

$source = [new S('a'), new S('b'), new S('c')];
$filter = [new S('b'), new S('c'), new S('d')];

$result = array_diff($source, $filter);

 $result теперь содержит один экземпляр S('a');


echo "Это работает: {$user_list['key']}";
echo "Это работает: {$user_list[4][3]}";
echo "Этот квадрат шириной {{${$people::softdrink}}->john}00 сантиметров.";
echo "Это работает: " . $user_list['foo'][3];
echo "Это тоже работает: {$people->values[3]->name}";
echo "Этот квадрат шириной {$people->john}00 сантиметров.";
print_r('<br>');
echo "Этот квадрат шириной {${$people::softdrink}}00 сантиметров.";
print_r('<br>');
echo "C:\\folder\\{$great}.txt"; // Работает, выводит: C:\folder\fantastic.txt




Перечисления ¶
(PHP 8 >= 8.1.0)

Основы перечислений ¶
Перечисления — это ограничивающий слой над классами и константами классов, предназначенный для предоставления способа определения закрытого набора возможных значений для типа.

enum Suit
{
    case Hearts;
    case Diamonds;
    case Clubs;
    case Spades;
}

function do_stuff(Suit $s)
{
    // ...
}

do_stuff(Suit::Spades);

Ресурсы ¶
Resource — это переменная, содержащая ссылку на внешний ресурс. Список функций, которые создают и работают с ресурсами, ограничен. Список всех таких функций и существующих типов ресурсов (resource) дан в приложении.


Освобождение ресурсов ¶
За счёт системы подсчёта ссылок, введённой в Zend Engine, ресурс, на который больше нет ссылок, обнаруживается автоматически и освобождается сборщиком мусора. Поэтому редко приходится освобождать память вручную.

Callable и callback-функции ¶
Callback-функции разрешено обозначать объявлением типа callable.

Функции вроде call_user_func() или usort() принимают определённые пользователем callback-функции в качестве параметра. Callback-функциями бывают как простые функции, так и методы объектов, включая статические методы классов.

Передача ¶
PHP-функция передаётся по имени в виде строки. Разрешено передавать любую встроенную или пользовательскую функцию, исключая языковые конструкции: array(), echo, empty(), eval(), exit(), isset(), list(), print или unset().

Метод созданного объекта (object) передаётся как массив, который в индексе 0 содержит — объект, а в индексе 1 — название метода. Изнутри класса разрешён доступ к закрытым и защищённым методам.

Статические методы класса тоже передаются — или как массив, в индексе 0 которого вместо передачи объекта указывают название класса, или как строка вида 'ClassName::methodName'.

Кроме пользовательских функций, в callback-параметр разрешено передавать анонимные и стрелочные функции.





 Пример #1 Пример callback-функции
 Пример callback-функции
function my_callback_function() {
    echo 'Привет, мир!';
}
 Пример callback-метода
class MyClass {
    static function myCallbackMethod() {
        echo 'Привет, мир!';
    }
}
 Тип 1: Простой callback
call_user_func('my_callback_function');
 Тип 2: Вызов статического метода класса
call_user_func(array('MyClass', 'myCallbackMethod'));
 Тип 3: Вызов метода класса
$obj = new MyClass();
call_user_func(array($obj, 'myCallbackMethod'));
 Тип 4: Вызов статического метода класса
call_user_func('MyClass::myCallbackMethod');
 Тип 5: Вызов относительного статического метода
class A {
    public static function who() {
        echo "A\n";
    }
}

class B extends A {
    public static function who() {
        echo "B\n";
    }
}

call_user_func(array('B', 'parent::who')); // A, устарело, начиная с PHP 8.2.0

 Тип 6: Объекты, которые реализуют магический метод __invoke, разрешено использовать как callable-объекты
class C {
    public function __invoke($name) {
        echo 'Привет ', $name, "\n";
    }
}

$c = new C();
call_user_func($c, 'PHP!');


If eval() is the answer, you're almost certainly asking the
wrong question. -- Rasmus Lerdorf, BDFL of PHP



Never ¶
never — тип, который допустимо указывать только как возвращаемое значение, которое указывает, что функция прекратит работу без возврата значения. Она либо вызывает конструкцию языка exit(), либо выбрасывает исключение, либо это бесконечный цикл. Поэтому его нельзя объявлять в объединении типов. Доступно с PHP 8.1.0.
На языке теории типов, never — нижний тип. Это означает, что он — подтип остальных типов и заменяет другие возвращаемые типы при наследовании.


function sayHello(string $name): never
{
    echo "Hello, $name";
    exit(); // if we comment this line, php throws fatal error
}

sayHello("John"); // result: "Hello, John"












Типы значений ¶
Типы значений — это те, которые проверяют тип значения и само значение. PHP поддерживает два типа значений: false с PHP 8.0.0 и true с PHP 8.2.0.

Внимание
До PHP 8.2.0 логический тип false можно было использовать только как часть объединения типов.

Замечание: Невозможно определить пользовательские типы значений. Вместо этого пользуются перечислениями.


Итерируемые значения ¶
Iterable — это встроенный псевдоним типа времени компиляции для array|Traversable. С момента появления в PHP 7.1.0 и до PHP 8.2.0 тип iterable был встроенным псевдотипом, который действовал как уже названный псевдоним типа, и допускался в качестве объявления типа. Тип iterable можно использовать с конструкцией foreach и с конструкцией yield from внутри генератора.

Замечание:

Функциям, которые объявляют в качестве возвращаемого типа iterable, также разрешено быть генераторами.

Пример #1 Пример возвращаемого типа итерируемого генератора


function gen(): iterable {
    yield 1;
    yield 2;
    yield 3;
}

https://www.php.net/manual/ru/language.types.declarations.php ??? чушь несусветаная про типы
https://www.php.net/manual/ru/language.types.type-juggling.php ??? чушь несусветаная про типы





Замечание: Под буквами здесь подразумеваются символы a-z, A-Z и байты от 128 до 255 (0x80-0xff).
Замечание: $this — это специальная переменная, которой нельзя ничего присваивать. До PHP 7.1.0 было возможно косвенное присвоение (например, с использованием переменных переменных).

По умолчанию переменные всегда присваиваются по значению.
 То есть, когда вы присваиваете выражение переменной,
 все значение оригинального выражения копируется в эту переменную.
 Это означает, к примеру, что после того как одной переменной присвоено значение другой, изменение одной из них не влияет на другую.




PHP также предлагает иной способ присвоения значений переменным: присвоение по ссылке.
 Это означает, что новая переменная просто ссылается
(иначе говоря, "становится псевдонимом" или "указывает") на оригинальную переменную.
 Изменения в новой переменной отражаются на оригинале, и наоборот.

Для присвоения по ссылке, просто добавьте амперсанд (&) к началу имени присваиваемой (исходной) переменной.
 Например, следующий фрагмент кода дважды выводит 'Меня зовут Боб':

<?php
$foo = 'Боб';              // Присваивает $foo значение 'Боб'
$bar = &$foo;              // Ссылка на $foo через $bar.
$bar = "Меня зовут $bar";  // Изменение $bar...
echo $bar;
echo $foo;                 // меняет и $foo.

Важно отметить, что по ссылке могут быть присвоены только именованные переменные.

$foo = 25;
$bar = &$foo;      // Это верное присвоение.
$bar = &(24 * 7);  // Неверно; ссылка на неименованное выражение.


function test()
{
    return 25;
}

$bar = &test();    // Неверно.



Пример #1 Значения по умолчанию в неинициализированных переменных

 Неустановленная И не имеющая ссылок (то есть без контекста использования) переменная; выведет NULL
var_dump($unset_var);

 Использование логической переменной; выведет 'false' (Подробнее по этому синтаксису смотрите раздел о тернарном операторе)
echo $unset_bool ? "true\n" : "false\n";

 Строковое использование; выведет 'string(3) "abc"'
$unset_str .= 'abc';
var_dump($unset_str);

 Целочисленное использование; выведет 'int(25)'
$unset_int += 25; // 0 + 25 => 25
var_dump($unset_int);

 Использование в качестве числа с плавающей точкой (float); выведет 'float(1.25)'
$unset_float += 1.25;
var_dump($unset_float);

 Использование в качестве массива; выведет array(1) {  [3]=>  string(3) "def" }
$unset_arr[3] = "def"; // array() + array(3 => "def") => array(3 => "def")
var_dump($unset_arr);

 Использование в качестве объекта; создаёт новый объект stdClass (смотрите http://www.php.net/manual/ru/reserved.classes.php)
 Выведет: object(stdClass)#1 (1) {  ["foo"]=>  string(3) "bar" }
$unset_obj->foo = 'bar';
var_dump($unset_obj);


I haven't found it anywhere else in the manual, so I'll make a note of it here - PHP will automatically replace any dots ('.') in an incoming variable name with underscores ('_'). So if you have dots in your incoming variables, e.g.:

example.com/page.php?chuck.norris=nevercries

you can not reference them by the name used in the URI:
//INCORRECT
echo $_GET['chuck.norris'];

instead you must use:
//CORRECT
echo $_GET['chuck_norris'];


Переменные переменных
https://www.php.net/manual/ru/language.variables.variable.php ??? чушь


















