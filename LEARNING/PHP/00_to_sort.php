<?php
/*
 all if, isset, is empty, type, true false, test null '' empty esset != == ets   examples

https://reqbin.com/code/php/0kvtdskv/php-array-to-json-example

Cross Site Scripting (XSS) vulnerabilities.

db injection, hash password

Межпроцессное взаимодействие в PHP Thread











Область видимости переменной ¶
Область видимости переменной - это контекст, в котором эта переменная определена. В большинстве случаев все переменные PHP имеют только одну область видимости. Эта единая область видимости охватывает также включаемые (include) и требуемые (require) файлы. Например:

<?php
$a = 1;
include 'b.inc';
Здесь переменная $a будет доступна внутри включённого скрипта b.inc. Однако определение (тело) пользовательской функции задаёт локальную область видимости данной функции. Любая используемая внутри функции переменная по умолчанию ограничена локальной областью видимости функции. Например:

$a = 1; /* глобальная область видимости 

function test()
{
    echo $a; /* ссылка на переменную в локальной области видимости 
}

test();
Этот скрипт выдаст диагностику неопределённой переменной E_WARNING (или E_NOTICE до версии PHP 8.0.0). Однако если в настройках INI display_errors установлено скрытие такой диагностики, то ничего выводиться не будет. Это связано с тем, что оператор echo указывает на локальную версию переменной $a, а в пределах этой области видимости ей не было присвоено значение. Возможно вы заметили, что это немного отличается от языка C в том, что глобальные переменные в C автоматически доступны функциям, если только они не были перезаписаны локальным определением. Это может вызвать некоторые проблемы, поскольку люди могут нечаянно изменить глобальную переменную. В PHP, если глобальная переменная будет использоваться внутри функции, она должна быть объявлена глобальной внутри определения функции.

Ключевое слово global ¶
Сначала пример использования global:

Пример #1 Использование global

<?php
$a = 1;
$b = 2;

function Sum()
{
    global $a, $b;

    $b = $a + $b;
}

Sum();
echo $b;
Вышеприведённый скрипт выведет 3. После определения $a и $b внутри функции как global все ссылки на любую из этих переменных будут указывать на их глобальную версию. Не существует никаких ограничений на количество глобальных переменных, которые могут обрабатываться функцией.

Второй способ доступа к переменным глобальной области видимости - использование специального, определяемого PHP массива $GLOBALS. Предыдущий пример может быть переписан так:

Пример #2 Использование $GLOBALS вместо global

$a = 1;
$b = 2;

function Sum()
{
    $GLOBALS['b'] = $GLOBALS['a'] + $GLOBALS['b'];
}

Sum();
echo $b;

Пример #4 Демонстрация необходимости статических переменных

function test()
{
    $a = 0;
    echo $a;
    $a++;
}
Эта функция довольно бесполезна, поскольку при каждом вызове она устанавливает $a в 0 и выводит 0. Инкремент переменной $a++ здесь не играет роли, так как при выходе из функции переменная $a исчезает. Чтобы написать полезную функцию подсчёта, которая не будет терять текущего значения счётчика, переменная $a объявляется как static:

Пример #5 Пример использования статических переменных

function test()
{
    static $a = 0;
    echo $a;
    $a++;
}
Теперь $a будет проинициализирована только при первом вызове функции, а каждый вызов функции test() будет выводить значение $a и инкрементировать его.

Статические переменные также дают возможность работать с рекурсивными функциями. Рекурсивной является функция, вызывающая саму себя. При написании рекурсивной функции нужно быть внимательным, поскольку есть вероятность сделать рекурсию бесконечной. Вы должны убедиться, что существует адекватный способ завершения рекурсии. Следующая простая функция рекурсивно считает до 10, используя для определения момента остановки статическую переменную $count:

Пример #6 Статические переменные и рекурсивные функции

function test()
{
    static $count = 0;

    $count++;
    echo $count;
    if ($count < 10) {
        test();
    }
    $count--;
}
Статическим переменным можно присвоить значения, являющиеся результатом выражения, но нельзя использовать для этого функцию, так это вызовет ошибку разбора.

Пример #7 Объявление статических переменных

function foo() {
    static $int = 0;          // верно
    static $int = 1+2;        // верно
    static $int = sqrt(121);  // неверно (поскольку это функция)

    $int++;
    echo $int;
}
Начиная с PHP 8.1.0, когда метод, использующий статические переменные, наследуется (но не переопределяется), унаследованный метод теперь будет использовать статические переменные совместно с родительским методом. Это означает, что статические переменные в методах теперь ведут себя так же, как статические свойства.

Пример #8 Использование статических переменных в унаследованных методах

class Foo {
    public static function counter() {
        static $counter = 0;
        $counter++;
        return $counter;
    }
}
class Bar extends Foo {}
var_dump(Foo::counter()); // int(1)
var_dump(Foo::counter()); // int(2)
var_dump(Bar::counter()); // int(3), до PHP 8.1.0 int(1)
var_dump(Bar::counter()); // int(4), до PHP 8.1.0 int(2)


Ссылки с глобальными (global) и статическими (static) переменными ¶
PHP использует модификаторы переменных static и global как ссылки. Например, реальная глобальная переменная, внедрённая в область видимости функции указанием ключевого слова global, в действительности создаёт ссылку на глобальную переменную. Это может привести к неожиданному поведению, как это показано в следующем примере:

<?php
function test_global_ref() {
    global $obj;
    $new = new stdClass;
    $obj = &$new;
}

function test_global_noref() {
    global $obj;
    $new = new stdClass;
    $obj = $new;
}

test_global_ref();
var_dump($obj);
test_global_noref();
var_dump($obj);
Результат выполнения приведённого примера:

NULL
object(stdClass)#1 (0) {
}

Аналогично ведёт себя и выражение static. Ссылки не хранятся статично:

function &get_instance_ref() {
    static $obj;

    echo 'Статический объект: ';
    var_dump($obj);
    if (!isset($obj)) {
        $new = new stdClass;
        // Присвоить ссылку статической переменной
        $obj = &$new;
    }
    if (!isset($obj->property)) {
        $obj->property = 1;
    } else {
        $obj->property++;
    }
    return $obj;
}

function &get_instance_noref() {
    static $obj;

    echo 'Статический объект: ';
    var_dump($obj);
    if (!isset($obj)) {
        $new = new stdClass;
        // Присвоить объект статической переменной
        $obj = $new;
    }
    if (!isset($obj->property)) {
        $obj->property = 1;
    } else {
        $obj->property++;
    }
    return $obj;
}

$obj1 = get_instance_ref();
$still_obj1 = get_instance_ref();
echo "\n";
$obj2 = get_instance_noref();
$still_obj2 = get_instance_noref();
Результат выполнения приведённого примера:

Статический объект: NULL
Статический объект: NULL

Статический объект: NULL
Статический объект: object(stdClass)#3 (1) {
  ["property"]=>
  int(1)
}
Этот пример демонстрирует, что при присвоении ссылки статической переменной она не запоминается, когда вы вызываете функцию &get_instance_ref() во второй раз.

Note that unlike Java and C++, variables declared inside blocks such as loops or if's, will also be recognized and accessible outside of the block, so:
for($j=0; $j<3; $j++)
{
     if($j == 1)
        $a = 4;
}
echo $a;

Would print 4.







Переменные извне PHP ¶
HTML-формы (GET и POST) ¶
Когда происходит отправка данных формы PHP-скрипту, информация из этой формы автоматически становится доступной ему. Существует несколько способов получения этой информации, например:

Пример #1 Простая HTML-форма

<form action="foo.php" method="post">
    Имя:  <input type="text" name="username" /><br />
    Email: <input type="text" name="email" /><br />
    <input type="submit" name="submit" value="Отправь меня!" />
</form>
Есть только два способа получить доступ к данным из форм HTML. Доступные сейчас способы приведены ниже:

Пример #2 Доступ к данным из простой HTML-формы, отправленной через POST

echo $_POST['username'];
echo $_REQUEST['username'];

 GET-форма используется аналогично, за исключением того, что вместо POST, вам нужно будет использовать соответствующую предопределённую переменную GET. GET относится также к QUERY_STRING (информация в URL после '?'). Так, например, http://www.example.com/test.php?id=3 содержит GET-данные, доступные как $_GET['id']. Смотрите также $_REQUEST.

Замечание:

Точки и пробелы в именах переменных преобразовывается в знаки подчёркивания. Например, <input name="a.b" /> станет $_REQUEST["a_b"].


if ($_POST) {
    echo '<pre>';
    echo htmlspecialchars(print_r($_POST, true));
    echo '</pre>';
}
Замечание: Если внешнее имя переменной начинается с корректного синтаксиса массива, завершающие символы молча игнорируются. Например, <input name="foo[bar]baz"> станет $_REQUEST['foo']['bar'].


Имена переменных кнопки-изображения ¶
При отправке формы вместо стандартной кнопки можно использовать изображение с помощью тега такого вида:

<input type="image" src="image.gif" name="sub" />
Когда пользователь щёлкнет где-нибудь на изображении, соответствующая форма будет передана на сервер с двумя дополнительными переменными — sub_x и sub_y. Они содержат координаты нажатия пользователя на изображение. Опытные программисты могут заметить, что на самом деле имена переменных, отправленных браузером, содержат точку, а не подчёркивание, но PHP автоматически преобразовывает точку в подчёркивание.






HTTP Cookies ¶
PHP прозрачно поддерживает HTTP cookies как определено в » RFC 6265. Cookies — это механизм для хранения данных в удалённом браузере и, таким образом, отслеживания и идентификации вернувшихся пользователей. Вы можете установить cookies, используя функцию setcookie(). Cookies являются частью HTTP-заголовка, поэтому функция SetCookie должна вызываться до того, как браузеру будет отправлен какой бы то ни было вывод. Это то же ограничение, что и для функции header(). Данные, хранящиеся в cookie, доступны в соответствующих массивах данных cookie, таких как $_COOKIE и $_REQUEST. Подробности и примеры смотрите в справочной странице setcookie().

Замечание: Начиная с PHP 7.2.34, 7.3.23 и 7.4.11, соответственно, имена входящих cookie больше не декодируются из URL-закодированной строки из соображений безопасности.

Если вы хотите присвоить множество значений одной переменной cookie, вы можете присвоить их как массив. Например:

  setcookie("MyCookie[foo]", 'Testing 1', time()+3600);
  setcookie("MyCookie[bar]", 'Testing 2', time()+3600);
Это создаст две разные cookie, хотя в вашем скрипте MyCookie будет теперь одним массивом. Если вы хотите установить именно одну cookie со множеством значений, сначала рассмотрите возможность использования к значениям такие функции, как serialize() или explode().

Обратите внимание, что cookie заменит предыдущую cookie с тем же именем в вашем браузере, если только путь или домен не отличаются. Так, для приложения корзины покупок вы, возможно, захотите сохранить счётчик. То есть:

Пример #4 Пример использования setcookie()

if (isset($_COOKIE['count'])) {
    $count = $_COOKIE['count'] + 1;
} else {
    $count = 1;
}
setcookie('count', $count, time()+3600);
setcookie("Cart[$count]", $item, time()+3600);
Точки в именах приходящих переменных ¶
Как правило, PHP не меняет передаваемых скрипту имён переменных. Однако следует отметить, что точка не является корректным символом в имени переменной PHP. Поэтому рассмотрим такую запись:

$varname.ext;  /* неверное имя переменной 
В данном случае интерпретатор видит переменную $varname, после которой идёт оператор конкатенации, а затем голая строка (то есть, не заключённая в кавычки строка, не соответствующая ни одному из ключевых или зарезервированных слов) 'ext'. Очевидно, что это не даст ожидаемого результата.
По этой причине важно отметить, что PHP будет автоматически заменять любые точки в именах, приходящих переменных на символы подчёркивания.

Определение типов переменных ¶
Поскольку PHP определяет типы переменных и преобразовывает их (как правило) по мере необходимости, не всегда очевидно, какой тип имеет данная переменная в любой момент времени. PHP содержит несколько функций, позволяющих определить тип переменной, таких как: gettype(), is_array(), is_float(), is_int(), is_object() и is_string(). Смотрите также раздел Типы.

HTTP является текстовым протоколом, и большинство, если не всё, содержимое, которое приходит в суперглобальные массивы, например, $_POST и $_GET, останется в виде строк. PHP не будет преобразовывать значения в определённый тип. В приведённом ниже примере $_GET["var1"] будет содержать строку "null", а $_GET["var2"] — строку "123".

/index.php?var1=null&var2=123



 Правильные имена констант
define("FOO",     "что-то");
define("FOO2",    "что-то ещё");
define("FOO_BAR", "что-то большее");

 Неправильные имена констант
define("2FOO",    "что-то");

 Это верное объявление, но лучше его не использовать:
 PHP однажды может зарегистрировать волшебную константу,
 которая нарушит работу скрипта
define("__FOO__", "что-то");

class Constants
{
    const MIN_VALUE = 0.0;      // RIGHT - Works INSIDE of a class definition.
    const MAX_VALUE = 1.0;      // RIGHT - Works INSIDE of a class definition.
    public static function getMinValue()

    {
        return self::MIN_VALUE;
    }

    public static function getMaxValue()
    {
        return self::MAX_VALUE;
    }

}

Константа может быть определена с помощью ключевого слова const или с помощью функции define(). В то время как define()
У констант нет приставки в виде знака доллара ($);
Константы могут быть определены и доступны в любом месте без учёта области видимости;
Константы не могут быть переопределены или удалены после первоначального объявления; и
Константы могут иметь только скалярные значения или массивы.

define("CONSTANT", "Здравствуй, мир.");
echo CONSTANT; // выводит "Здравствуй, мир."
echo Constant; // Выбросит ошибку: Неопределённая константа "Constant"
 До PHP 8.0.0 выводит "Constant" и выдаёт предупреждение.

Определение констант с помощью ключевого слова const
 Простое скалярное значение
const CONSTANT = 'Здравствуй, мир.';

echo CONSTANT;

 Скалярное выражение
const ANOTHER_CONST = CONSTANT . ' Прощай, мир.';
echo ANOTHER_CONST;

const ANIMALS = array('dog', 'cat', 'bird');
echo ANIMALS[1]; // выводит "cat"

 Массивы в константе
define('ANIMALS', array(
    'dog',
    'cat',
    'bird'
));
echo ANIMALS[1]; // выводит "cat"

В отличие от определения констант с помощью функции define(), константы, объявленные с помощью ключевого слова const должны быть объявлены в самой верхней области видимости, потому что они определяются при компилировании скрипта. Это означает, что их нельзя объявлять внутри функций, циклов, выражений if и блоков try/ catch.




Предопределённые константы ¶
Предопределённые константы ядра ¶
Эти константы определяет ядро PHP. Сюда входят PHP, движок Zend и SAPI-модули.

PHP_VERSION (string)
Текущая версия PHP в виде строки в формате «major.minor.release[extra]».
PHP_MAJOR_VERSION (int)
Текущая «основная» (major) версия PHP в виде целого числа (например, int(5) для версии «5.2.7-extra»).
PHP_MINOR_VERSION (int)
Текущая «промежуточная» (minor) версия PHP в виде целого числа (например, int(2) для версии «5.2.7-extra»).
PHP_RELEASE_VERSION (int)
Текущая «релиз»-версия (release) PHP в виде целого числа (например, int(7) для версии «5.2.7-extra»).
PHP_VERSION_ID (int)
Текущая версия PHP в виде целого числа, её удобно использовать при сравнениях версий (например, int(50207) для версии «5.2.7-extra»).
PHP_EXTRA_VERSION (string)
Текущая «экстра»-версия PHP в виде строки (например, «-extra» для версии «5.2.7-extra»). Обычно используется в различных дистрибутивах для индикации версий пакетов.
ZEND_THREAD_SAFE (bool)
Указывает, потокобезопасна ли текущая сборка PHP.
ZEND_DEBUG_BUILD (bool)
Указывает, собран ли PHP для отладки.
PHP_ZTS (int)
Указывает, потокобезопасна ли текущая сборка PHP.
PHP_DEBUG (int)
Указывает, собран ли PHP для отладки.
PHP_MAXPATHLEN (int)
Максимальная длина файловых имён (включая путь), поддерживаемая данной сборкой PHP.
PHP_OS (string)
Операционная система, под которую собирался PHP.
PHP_OS_FAMILY (string)
Семейство операционных систем, для которых собран PHP. Любая из «Windows», «BSD», «Darwin», «Solaris», «Linux» или «unknown». Константа доступна с PHP 7.2.0.
PHP_SAPI (string)
API сервера (Server API) данной сборки PHP. Смотрите также php_sapi_name().
PHP_EOL (string)
Корректный символ конца строки (End Of Line) для платформы.
PHP_INT_MAX (int)
Максимальное целое число, поддерживаемое сборкой PHP. Обычно это int(2147483647) в 32-битных системах и int(9223372036854775807) в 64-битных.
PHP_INT_MIN (int)
Минимальное целое число, поддерживаемое сборкой PHP. Обычно это int(-2147483648) в 32-битных системах и int(-9223372036854775808) в 64-битных. Обычно PHP_INT_MIN === ~PHP_INT_MAX.
PHP_INT_SIZE (int)
Размер целого числа в байтах в сборке PHP.
PHP_FLOAT_DIG (int)
Количество десятичных цифр, которые могут быть округлены в числе с плавающей точкой (float) и обратно без потери точности. Константа доступна с PHP 7.2.0.
PHP_FLOAT_EPSILON (float)
Наименьшее представимое положительное число x, такое, что x + 1.0 != 1.0. Константа доступна с PHP 7.2.0.
PHP_FLOAT_MIN (float)
Наименьшее представимое положительное число с плавающей точкой float. Если нужно наименьшее представимое отрицательное число с плавающей точкой float, указывают - PHP_FLOAT_MAX. Константа доступна с PHP 7.2.0.
PHP_FLOAT_MAX (float)
Максимальное представимое число с плавающей точкой float. Константа доступна с PHP 7.2.0.
DEFAULT_INCLUDE_PATH (string)
PEAR_INSTALL_DIR (string)
PEAR_EXTENSION_DIR (string)
PHP_EXTENSION_DIR (string)
Каталог по умолчанию, в котором нужно искать динамически загружаемые модули (если он не переопределён директивой extension_dir). По умолчанию — PHP_PREFIX (или PHP_PREFIX . "\\ext" в Windows).
PHP_PREFIX (string)
Значение --prefix было установлено при настройке. В Windows это значение --with-prefix было установлено при настройке.
PHP_BINDIR (string)
Значение --bindir было установлено при настройке. В Windows это значение --with-prefix было установлено при настройке.
PHP_BINARY (string)
Указывает путь к исполняемым файлам PHP во время выполнения скрипта.
PHP_MANDIR (string)
Указывает, куда были установлены страницы руководства (manpages).
PHP_LIBDIR (string)
PHP_DATADIR (string)
PHP_SYSCONFDIR (string)
PHP_LOCALSTATEDIR (string)
PHP_CONFIG_FILE_PATH (string)
PHP_CONFIG_FILE_SCAN_DIR (string)
PHP_SHLIB_SUFFIX (string)
Суффикс разделяемых (динамических) модулей платформы-сборки, например, «so» (большинство Unix-систем) или «dll» (Windows).
PHP_FD_SETSIZE (int)
Максимальное количество файловых дескрипторов для системных вызовов. Константа доступна с PHP 7.1.0.
E_ERROR (int)
Константа сообщения об ошибке
E_WARNING (int)
Константа сообщения об ошибке
E_PARSE (int)
Константа сообщения об ошибке
E_NOTICE (int)
Константа сообщения об ошибке
E_CORE_ERROR (int)
Константа сообщения об ошибке
E_CORE_WARNING (int)
Константа сообщения об ошибке
E_COMPILE_ERROR (int)
Константа сообщения об ошибке
E_COMPILE_WARNING (int)
Константа сообщения об ошибке
E_USER_ERROR (int)
Константа сообщения об ошибке
E_USER_WARNING (int)
Константа сообщения об ошибке
E_USER_NOTICE (int)
Константа сообщения об ошибке
E_RECOVERABLE_ERROR (int)
Константа сообщения об ошибке
E_DEPRECATED (int)
Константа сообщения об ошибке
E_USER_DEPRECATED (int)
Константа сообщения об ошибке
E_ALL (int)
Константа сообщения об ошибке
E_STRICT (int)
Константа сообщения об ошибке
__COMPILER_HALT_OFFSET__ (int)
true (bool)
Смотрите раздел Логический тип.
false (bool)
Смотрите раздел Логический тип.
null (null)
Смотрите Null.
PHP_WINDOWS_EVENT_CTRL_C (int)
Событие Windows CTRL + C. Константа доступна с PHP 7.4.0 (только для Windows).
PHP_WINDOWS_EVENT_CTRL_BREAK (int)
Событие Windows CTRL + BREAK. Константа доступна с PHP 7.4.0 (Только для Windows).
PHP_CLI_PROCESS_TITLE (bool)
Указывает, доступны ли настройка и получение названия процесса. Константа доступна только в SAPI-интерфейсе командной строки CLI.
STDERR (resource)
Уже открытый поток для стандартного вывода ошибок stderr. Константа доступна только в SAPI-интерфейсе командной строки CLI.
STDIN (resource)
Уже открытый поток для стандартного ввода stdin. Константа доступна только в SAPI-интерфейсе командной строки CLI.
STDOUT (resource)
Уже открытый поток для стандартного вывода stdout. Константа доступна только в SAPI-интерфейсе командной строки CLI.


Магические константы PHP
__LINE__	Текущий номер строки в файле.
__FILE__	Полный путь и имя текущего файла с развёрнутыми симлинками. Если используется внутри подключаемого файла, то возвращается имя данного файла.
__DIR__	Директория файла. Если используется внутри подключаемого файла, то возвращается директория этого файла. Это эквивалентно вызову dirname(__FILE__). Возвращаемое имя директории не оканчивается на слеш, за исключением корневой директории.
__FUNCTION__	Имя функции или {closure} в случае анонимной функции.
__CLASS__	Имя класса. Это имя содержит название пространства имён, в котором класс был объявлен (например, Foo\Bar). При использовании в методах трейтов __CLASS__ является именем класса, в котором эти методы используется.
__TRAIT__	Имя трейта. Это имя содержит название пространства имён, в котором трейт был объявлен (например, Foo\Bar).
__METHOD__	Имя метода класса.
__NAMESPACE__	Имя текущего пространства имён.
ClassName::class	Полное имя класса.



Зарезервированные слова
int	float	bool	string
true	false	null	void (с PHP 7.1)
iterable (с PHP 7.1)	object (с PHP 7.2)	mixed (с PHP 8.0)	never (с PHP 8.1)

Мягко зарезервированные слова
enum	resource	numeric



https://www.php.net/manual/ru/resource.php ???


Выражения — это самые важные строительные элементы PHP. Почти всё, что разработчик пишет в PHP, — выражение. Самое простое и точное определение выражения — «всё, у чего есть значение».


Префиксный инкремент, записываемый как ++$variable, вычисляется в инкрементированное значение (PHP инкрементирует переменную до того как прочесть её значение, отсюда название «преинкремент»). Постфиксный инкремент, записываемый как $variable++, вычисляется в первоначальное значение переменной $variable до её приращения (PHP вначале читает значение переменной и только потом инкрементирует её, отсюда название «постинкремент»).

Распространённые типы выражений — это выражения сравнения. Эти выражения оцениваются либо как false (ложь), либо как true (истина). PHP поддерживает операции сравнения > (больше), >= (больше либо равно), == (равно), != (не равно), < (меньше) и <= (меньше либо равно). Он также поддерживает операторы строгого равенства: === (равно и одного типа) и !== (не равно или не одного типа). Обычно этими выражениями пользуются в операторах условного выполнения, например, инструкции if.



Последний пример выражений, который будет здесь рассмотрен, это смешанные выражения операции и присвоения. Мы уже знаем, что если нужно увеличить значение переменной $a на 1, можно просто написать $a++ или ++$a. Но что, если нужно прибавить больше единицы, например, 3? Можно было бы написать $a++ много раз, однако, очевидно, это не очень рационально и удобно. Более распространённая практика — запись вида $a = $a + 3. Выражение $a + 3 вычисляется в значение переменной $a, к которому прибавлено 3 и снова присвоено значение переменной $a, увеличивая в результате значение переменной $a на 3. В PHP, как и в ряде других языков, например Си, разрешено записать это более коротким образом, что увеличит очевидность смысла и скорость понимания кода по прошествии времени. Прибавить 3 к текущему значению переменной $a можно, записав $a += 3. Это означает дословно «взять значение $a, прибавить к нему 3 и снова присвоить его переменной $a». Кроме большей понятности и краткости, это быстрее работает. Значением выражения $a += 3, как и обычного присвоения, будет присвоенное значение. Обратите внимание, что это НЕ 3, а суммированное значение переменной $a плюс 3 (то, что было присвоено перменной $a). Поэтому разрешено использовать любой бинарный оператор, например, $a -= 5 (вычесть 5 из значения переменной $a), $b *= 7 (умножить значение переменной $b на 7) и т. д.




$first ? $second : $third
    Если значение первого подвыражения — true (ненулевое значение), то выполняется второе подвыражение, которое и будет результатом условного выражения. Или выполняется третье подвыражение и его значение будет результатом.

    Задача следующего примера — помочь немного улучшить понимание префиксного и постфиксного инкремента и выражений:


function double($i)
{
    return $i*2;
}

$b = $a = 5;        /* присвоить значение пять переменным $a и $b 
$c = $a++;          /* постфиксный инкремент, присвоить значение переменной
                       $a (5) — переменной $c 
$e = $d = ++$b;     /* префиксный инкремент, присвоить увеличенное
                       значение переменной $b (6) — переменным $d и $e 

/* в этой точке и переменная $d, и переменная $e равны 6 

$f = double($d++);  /* присвоить удвоенное значение перменной $d перед
                       инкрементом (2 * 6 = 12) — переменной $f 
$g = double(++$e);  /* присвоить удвоенное значение перменной $e после
                       инкремента (2 * 7 = 14) — переменной $g 
$h = $g += 10;      /* сначала переменная $g увеличивается на 10,
                       приобретая, в итоге, значение 24. Затем значение
                       присвоения (24) присваивается переменной $h,
                       которая в итоге также становится равной 24. 


Операторы можно сгруппировать по количеству принимаемых ими значений. Унарные операторы принимают только одно значение, например, ! (оператор логического отрицания) или ++ (инкремент). Бинарные операторы принимают два значения; это, например, знакомые всем арифметические операторы + (плюс) и - (минус), бо́льшая часть поддерживаемых в PHP операторов входит в эту категорию. И на последок, существует всего один тернарный оператор, ? :, принимающий три значения, обычно о нём говорят просто — «тернарный оператор» (хотя, возможно, более точным названием было бы «условный оператор»).


/*
Порядок выполнения операторов
Ассоциативность	Оператор	Дополнительная информация
(н/а)	clone new	clone и new
правая	**	арифметические операторы
(н/а)	+ - ++ -- ~ (int) (float) (string) (array) (object) (bool) @	арифметические операторы (унарные + и -), инкремент/декремент, побитовые операторы, приведение типов и оператор управления ошибками
левая	instanceof	типы
(н/а)	!	логические операторы
левая	* / %	арифметические операторы
левая	+ - .	арифметические операторы (бинарные + и -), операторы, работающие с массивами и строковые операторы (. до PHP 8.0.0)
левая	<< >>	побитовые операторы
левая	.	строковые операторы (начиная с PHP 8.0.0)
неассоциативна	< <= > >=	операторы сравнения
неассоциативна	== != === !== <> <=>	операторы сравнения
левая	&	побитовые операторы и ссылки
левая	^	побитовые операторы
левая	|	побитовые операторы
левая	&&	логические операторы
левая	||	логические операторы
правая	??	операторы сравнения с null
неассоциативна	? :	тернарный оператор (левоассоциативный до PHP 8.0.0)
правая	= += -= *= **= /= .= %= &= |= ^= <<= >>= ??=	операторы присваивания
(н/а)	yield from	yield from
(н/а)	yield	yield
(н/а)	print	print
левая	and	логические операторы
левая	xor	логические операторы
левая	or	логические операторы
 *
 * 


Пример #1 Ассоциативность

<?php

$a = 3 * 3 % 5; // (3 * 3) % 5 = 4
// ассоциативность тернарных операторов отличается от C/C++
$a = true ? 0 : true ? 1 : 2; // (true ? 0 : true) ? 1 : 2 = 2 (до PHP 8.0.0)

$a = 1;
$b = 2;
$a = $b += 3; // $a = ($b += 3) -> $a = 5, $b = 5
Приоритет и ассоциативность оператора определяет только то, как группируется выражение, а не порядок его вычисления. Обычно PHP не указывает, в каком порядке вычисляются выражения, и нужно избегать кода, который предполагает спецефический порядок вычисления, потому что поведение может меняться в разных версиях PHP или в зависимости от окружающего кода.

Пример #2 Неопределённый порядок вычисления

<?php

$a = 1;
echo $a + $a++; // может вывести как 2, так и 3

$i = 1;
$array[$i] = $i++; // может установить индекс как 1, так 2
Пример #3 +, - и . имеют одинаковый приоритет (до PHP 8.0.0)

<?php

$x = 4;
// следующий код может выдать неожиданный результат:
echo "x минус 1 равно " . $x-1 . ", ну, я надеюсь\n";

// поскольку он вычисляется таким образом (до PHP 8.0.0):
echo (("x минус один равно " . $x) - 1) . ", ну, я надеюсь\n";

// требуемый приоритет следует задать скобками:
echo "x минус 1 равно " . ($x-1) . ", ну, я надеюсь\n";
Результат выполнения приведённого примера:

-1, ну, я надеюсь
-1, ну, я надеюсь
x минус один равно 3, ну, я надеюсь


/*

Арифметические операции
Пример	Название	Результат
+$a	Идентичность	Конвертация значения переменной $a в целое число (int) или число с плавающей точкой (float), если нужно.
-$a	Отрицание	Смена знака $a.
$a + $b	Сложение	Сумма $a и $b.
$a - $b	Вычитание	Разность $a и $b.
$a * $b	Умножение	Произведение $a и $b.
$a / $b	Деление	Частное от деления $a на $b.
$a % $b	Деление по модулю	Целочисленный остаток от деления $a на $b.
$a ** $b	Возведение в степень	Возведение значения переменной $a в степень, указанную в переменной $b.


Пример #1 Пример использования функции fmod()
$x = 5.7;
$y = 1.3;
$r = fmod($x, $y);
 Значение переменной $r равно 0.5, потому что 4 * 1.3 + 0.5 = 5.7

Пример использования функции intdiv()
Возвращает целое частное от деления числа num1 на число num2.

var_dump(intdiv(3, 2));
var_dump(intdiv(-3, 2));
var_dump(intdiv(3, -2));
var_dump(intdiv(-3, -2));
var_dump(intdiv(PHP_INT_MAX, PHP_INT_MAX));
var_dump(intdiv(PHP_INT_MIN, PHP_INT_MIN));
var_dump(intdiv(PHP_INT_MIN, -1));
var_dump(intdiv(1, 0));


Операторы инкремента и декремента
Пример	Название	Действие
++$a	Префиксный инкремент	Увеличивает $a на единицу, затем возвращает значение $a.
$a++	Постфиксный инкремент	Возвращает значение $a, затем увеличивает $a на единицу.
--$a	Префиксный декремент	Уменьшает $a на единицу, затем возвращает значение $a.
$a--	Постфиксный декремент	Возвращает значение $a, затем уменьшает $a на единицу.
Приведём пример простого скрипта:

<?php

echo 'Постфиксный инкремент:', PHP_EOL;
$a = 5;
var_dump($a++);
var_dump($a);

echo 'Префиксный инкремент:', PHP_EOL;
$a = 5;
var_dump(++$a);
var_dump($a);

echo 'Постфиксный декремент:', PHP_EOL;
$a = 5;
var_dump($a--);
var_dump($a);

echo 'Префиксный декремент:', PHP_EOL;
$a = 5;
var_dump(--$a);
var_dump($a);
Результат выполнения приведённого примера:

Постфиксный инкремент:
int(5)
int(6)
Префиксный инкремент:
int(6)
int(6)
Постфиксный декремент:
int(5)
int(4)
Префиксный декремент:
int(4)
int(4)


Операторы присваивания ¶

$a = ($b = 4) + 5; // Значение переменной $a равно 9, а переменной $b присвоено значение 4.
$a = 3;
$a += 5; // устанавливает для переменной $a значение 8, как если бы было написано: $a = $a + 5;
$b = "Привет";
$b .= "-привет!"; // устанавливает переменной $b значение «Привет-привет!», как и $b = $b . "-привет!";

$a = 3;
$b = &$a; // $b — это ссылка на переменную $a

print "$a\n"; // печатает 3
print "$b\n"; // печатает 3

$a = 4; // меняем переменную $a

print "$a\n"; // печатает 4
print "$b\n"; // также печатает 4, так как переменная $b — это ссылка на переменную $a,
              // а значение переменной $a успело измениться



Оператор new автоматически возвращает ссылку, поэтому присваивание результата операции new по ссылке вызывает ошибку.

class C {}

$o = &new C;
Parse error: syntax error, unexpected 'new' (T_NEW) in …

Операторы арифметического присваивания ¶
Пример	Эквивалент	Операция
$a += $b	$a = $a + $b	Сложение
$a -= $b	$a = $a - $b	Вычитание
$a *= $b	$a = $a * $b	Умножение
$a /= $b	$a = $a / $b	Деление
$a %= $b	$a = $a % $b	Модуль
$a **= $b	$a = $a ** $b	Возведение в степень
Операторы побитового присваивания ¶
Пример	Эквивалент	Операция
$a &= $b	$a = $a & $b	Побитовое И
$a |= $b	$a = $a | $b	Побитовое ИЛИ
$a ^= $b	$a = $a ^ $b	Побитовое исключающее ИЛИ (Xor)
$a <<= $b	$a = $a << $b	Побитовый сдвиг влево
$a >>= $b	$a = $a >> $b	Побитовый сдвиг вправо
Другие операторы присваивания ¶
Пример	Эквивалент	Операция
$a .= $b	$a = $a . $b	Конкатенация строк
$a ??= $b	$a = $a ?? $b	Объединение с Null



???
Using $text .= "additional text"; instead of $text =  $text ."additional text"; can seriously enhance performance due to memory allocation efficiency.
I reduced execution time from 5 sec to .5 sec (10 times) by simply switching to the first pattern for a loop with 900 iterations over a string $text that reaches 800K by the end.



https://www.php.net/manual/ru/language.operators.bitwise.php ???

Побитовые операторы
Пример	Название	Результат
$a & $b	И	Биты, которые установлены и в переменной $a, и в переменной $b.
$a | $b	Или	Будут заданы биты, которые установлены или в переменной $a, или в переменной $b.
$a ^ $b	Исключающее или	Будут заданы биты, которые установлены либо только в переменной $a, либо только в переменной $b, но не в обоих одновременно.
~ $a	Отрицание	Будут заданы биты, которые не установлены в переменной $a, и наоборот.
$a << $b	Сдвиг влево	Все биты переменной $a сдвигаются влево на количествво позиций, указанных в переменной $b (каждая позиция предполагает «умножение на 2»)
$a >> $b	Сдвиг вправо	Все биты переменной $a сдвигаются вправо на количество позиций, указанных в переменной $b (каждая позиция предполагает «деление на 2»)
Побитовый сдвиг в PHP — это арифметическая операция. Биты, сдвинутые за границы числа, отбрасываются. Сдвиг влево дополняет число нулями справа, при этом сдвигая знаковый бит числа влево, что означает что знак операнда не сохраняется. Сдвиг вправо сохраняет копию сдвинутого знакового бита слева, что означает что знак операнда сохраняется.

Приоритет операторов изменяют скобками. Например, выражение $a & $b == true сначала проверяет на равенство, а потом выполняет побитовое «И»; тогда как выражение ($a & $b) == true сначала выполняет побитовое «И», а потом выполняет проверку на равенство.

Если оба операнда для операторов &, | и ^ строки, то операция будет проведена с кодами ASCII всех символов строки и в результате вернёт строку. Во всех остальных случаях, оба операнда будут преобразованы к целому и результатом будет целое число.

Если операнд для оператора ~ строка, то операция будет проведена с кодами ASCII всех символов строки и в результате вернёт строку, иначе как операнд, так и результат, будут считаться целыми.

И операнды, и результат выполнения операторов << и >> рассматриваются как целые числа.

     В PHP ini-настройка error_reporting использует побитовые значения,
     показывая, как практически снимать значения битов.
     Чтобы показать все ошибки, кроме замечаний,
     инструкции в файле php.ini говорят, что нужно указать:
     E_ALL & ~E_NOTICE

     Начинаем со значения E_ALL:
     00000000000000000111011111111111
     Затем берём значение E_NOTICE...
     00000000000000000000000000001000
     ... и инвертируем его оператором ~:
     11111111111111111111111111110111
     Наконец, указываем побитовое И (&), чтобы установить только те биты,
     которые установлены в единицу в обоих значениях:
     00000000000000000111011111110111

     Другой способ достичь этого  — использовать ИСКЛЮЧАЮЩЕЕ ИЛИ (XOR, ^),
     чтобы получить только те биты, которые установлены в единицу
     либо только в одном, либо только в другом значении:
     E_ALL ^ E_NOTICE

     Через настройку опции error_reporting можно также показать,
     как устанавливать биты. Показать только ошибки и обрабатываемые ошибки можно
     так:
     E_ERROR | E_RECOVERABLE_ERROR

     Здесь процесс сочетает E_ERROR
     00000000000000000000000000000001
     и
     00000000000000000001000000000000
     через оператор ИЛИ (|),
     чтобы получить биты, установленные хотя бы в одном операнде:
     00000000000000000001000000000001





Операторы сравнения
Пример	Название	Результат
$a == $b	Равно	Возвращается true, если значение переменной $a после преобразования типов равно значению переменной $b.
$a === $b	Тождественно равно	Возвращается true, если значение переменной $a равно значению переменной $b и имеет тот же тип.
$a != $b	Не равно	Возвращается true, если значение переменной $a после преобразования типов не равно значению переменной $b.
$a <> $b	Не равно	Возвращается true, если значение переменной $a после преобразования типов не равно значению переменной $b.
$a !== $b	Тождественно не равно	Возвращается true, если значение переменной $a не равно значению переменной $b или они разных типов.
$a < $b	Меньше	Возвращается true, если значение переменной $a строго меньше значения переменной $b.
$a > $b	Больше	Возвращается true, если значение переменной $a строго больше значения переменной $b.
$a <= $b	Меньше или равно	Возвращается true, если значение переменной $a меньше или равно значению переменной $b.
$a >= $b	Больше или равно	Возвращается true, если значение переменной $a больше или равно значению переменной $b.
$a <=> $b	Космический корабль (spaceship)	Целое число (int) меньше, больше или равное нулю, когда значение переменной $a меньше, больше или равно значению переменной $b.

Если оба операнда — строки, содержащие числа, или один операнд — число, а другой — строка, содержащая числа, то сравнение выполняется численно. Эти правила также справедливы для оператора switch. Тип не преобразовывается при сравнениях вида === или !==, поскольку это включает сравнение типа, а также значения.


 Пример выражения с тернарным оператором
$action = (empty($_POST['action'])) ? 'default' : $_POST['action'];

 Код выше аналогичен блоку с конструкциями if/else
if (empty($_POST['action'])) {
    $action = 'default';
} else {
    $action = $_POST['action'];
}

Оператор объединения с null ¶
Другой полезный сокращённый оператор — это оператор объединения с NULL — «??» (null coalescing).

Пример #6 Присваивание значения по умолчанию



 Пример работы с оператором нулевого слияния
$action = $_POST['action'] ?? 'default';

 Пример выше аналогичен этому выражению с if/else
if (isset($_POST['action'])) {
    $action = $_POST['action'];
} else {
    $action = 'default';


























